image: docker:latest

# build -> push -> delivery
stages:
  - build_step_1
  - test
  - push_step_1
  - build_step_2
  - push_step_2

variables:
  PHP_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/app"
  PHP_IMAGE_TMP: "${CI_REGISTRY_IMAGE}/app:${CI_COMMIT_SHORT_SHA}"
  APACHE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/apache"
  APACHE_IMAGE_TMP: "${CI_REGISTRY_IMAGE}/apache:${CI_COMMIT_SHORT_SHA}"
  AWS_REGISTRY: "AWS_ACCOUNT_ID."
  AWS_ECR_PHP_IMAGE: "$AWS_REGISTRY/$CI_PROJECT_NAME/app"
  AWS_ECR_APACHE_IMAGE: "$AWS_REGISTRY/$CI_PROJECT_NAME/apache"
  AWS_REPOSITORY_APP_NAME: "$CI_PROJECT_NAME/app"
  AWS_REPOSITORY_APACHE_NAME: "$CI_PROJECT_NAME/apache"
  FARGATE_DOMAIN: "fargate.opencontent.io"
  LB: fargate-lb
  PORT: http:3000
  NETWORKING: "--security-group-id sg-09623de76fa990898 --subnet-id subnet-0b05fd8af8e3414bf --subnet-id subnet-07a1e55f83f380f87 --subnet-id subnet-0fe7f82bfcc0200b3"

services:
  - docker:dind

build_php:
  stage: build_step_1
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  script:
    - docker pull  $PHP_IMAGE_TMP 2> /dev/null || docker build --pull -t $PHP_IMAGE_TMP . 
    - docker push  $PHP_IMAGE_TMP
  only:
    - branches
    - tags

build_apache:
  stage: build_step_2
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  script:
    - docker pull  $APACHE_IMAGE_TMP 2> /dev/null || docker build --file Dockerfile.apache --pull --build-arg php_image=$PHP_IMAGE_TMP -t $APACHE_IMAGE_TMP .
    - docker push  $APACHE_IMAGE_TMP
  only:
    - branches
    - tags





push_php_branch:
  stage: push_step_1
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  script:
    - docker pull $PHP_IMAGE_TMP
    - docker tag $PHP_IMAGE_TMP "$PHP_IMAGE_NAME:${CI_COMMIT_REF_NAME/\//-}" 
    - docker push "$PHP_IMAGE_NAME:${CI_COMMIT_REF_NAME/\//-}"
  only:
    - branches
  except:
    - master

push_php_tag:
  stage: push_step_1
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  script:
    - docker pull $PHP_IMAGE_TMP
    - docker tag $PHP_IMAGE_TMP "$PHP_IMAGE_NAME:$CI_COMMIT_TAG"
    - docker push "$PHP_IMAGE_NAME:$CI_COMMIT_TAG"
  only:
    - tags

push_php_latest:
  stage: push_step_1
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  script:
    - docker pull $PHP_IMAGE_TMP
    - docker tag $PHP_IMAGE_TMP "$PHP_IMAGE_NAME:latest"
    - docker push "$PHP_IMAGE_NAME:latest"
  only:
    - master




push_apache_branch:
  stage: push_step_2
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  script:
    - docker pull $APACHE_IMAGE_TMP
    - docker tag $APACHE_IMAGE_TMP "$APACHE_IMAGE_NAME:${CI_COMMIT_REF_NAME/\//-}" 
    - docker push "$APACHE_IMAGE_NAME:${CI_COMMIT_REF_NAME/\//-}"
  only:
    - branches
  except:
    - master

push_apache_tag:
  stage: push_step_2
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  script:
    - docker pull $APACHE_IMAGE_TMP
    - docker tag $APACHE_IMAGE_TMP "$APACHE_IMAGE_NAME:$CI_COMMIT_TAG"
    - docker push "$APACHE_IMAGE_NAME:$CI_COMMIT_TAG"
  only:
    - tags

push_apache_latest:
  stage: push_step_2
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  script:
    - docker pull $APACHE_IMAGE_TMP
    - docker tag $APACHE_IMAGE_TMP "$APACHE_IMAGE_NAME:latest"
    - docker push "$APACHE_IMAGE_NAME:latest"
  only:
    - master






# Push to ECR registry just production images
push_php_tags_to_ecr:
  stage: push_step_1
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
    - apk add --no-cache python py-pip
    - pip install awscli
    - $(aws ecr get-login --no-include-email | sed 's|https://||')
    - aws ecr describe-repositories --repository-names $CI_PROJECT_NAME 2> /dev/null || aws ecr create-repository --repository-name $CI_PROJECT_NAME
  script:
    - docker pull $PHP_IMAGE_TMP
    - docker tag $PHP_IMAGE_TMP "AWS_ECR_PHP_IMAGE:$CI_COMMIT_TAG"
    - docker push "$AWS_ECR_PHP_IMAGE:$CI_COMMIT_TAG"
  only:
    - tags

# Push to ECR registry just production images
push_apache_tags_to_ecr:
  stage: push_step_2
  before_script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
    - apk add --no-cache python py-pip
    - pip install awscli
    - $(aws ecr get-login --no-include-email | sed 's|https://||')
    - aws ecr describe-repositories --repository-names $CI_PROJECT_NAME 2> /dev/null || aws ecr create-repository --repository-name $CI_PROJECT_NAME
  script:
    - docker pull $APACHE_IMAGE_TMP
    - docker tag $APACHE_IMAGE_TMP "$AWS_ECR_APACHE_IMAGE:$CI_COMMIT_TAG"
    - docker push "$AWS_ECR_APACHE_IMAGE:$CI_COMMIT_TAG"
  only:
    - tags


zap_baseline:
  stage: test
  allow_failure: true
  script:
    - docker run -v $(pwd):/zap/wrk/:rw -t owasp/zap2docker-stable zap-baseline.py -t https://devsdc.opencontent.it/comune-di-ala/
    # -z -config rules.csrf.ignorelist=search,login then ZAP will not fail the scan if forms with an ID of "search" or "login" do not have anti CSRF tokens.
    # - docker run -t owasp/zap2docker-stable zap-baseline.py -j -t https://10.0.1.22/ # with ajax scanning

publiccode:
    stage: test
    allow_failure: false
    script:
      - docker run -v $(pwd):/var/tmp:ro -t --rm golang sh -c "go get github.com/italia/publiccode-parser-go/pcvalidate; cd /var/tmp; /go/bin/pcvalidate -remote-base-url https://gitlab.com/opencontent/stanzadelcittadino/raw/master publiccode.yml"


dummy_protocol:
    stage: test
    allow_failure: false
    script:
      - echo "Looking for configuration files containing protocollo.handlers.dummy:"
      - find app/config -type f -name "config_prod.yml" -exec grep -H protocollo.handlers.dummy {} \;
      - if [[ $(find app/config -type f -name "config_prod.yml" -exec grep -H protocollo.handlers.dummy {} \; | wc -l) -gt 0 ]]; then echo "Error, at least one production file contains dummy protocol!" && exit 1; else echo "OK, no dummy protocol in production files"; fi

# vim: set noet sw=4 ts=4:        

